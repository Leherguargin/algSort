{
  "sortowanie bąbelkowe": "Algorytm sortowania bąbelkowego polega na kolejnym porównywaniu ze sobą sąsiadujących elementów i w przypadku gdy drugi z porównywanych elementów jest mniejszy od pierwszego zamieniania ich kolejnością. Przez takie podejście po pierwszym przebiegu po wszystkich elementach największy element (w przypadku sortowania rosnąco i zaczynając od początku sortowanej tablicy wejściowej) zostanie na końcu tablicy (stąd nazwa – sortowanie bąbelkowe, ponieważ największy element „wypływa” na koniec jak bąbelki gazu w cieczy), zatem w kolejnym przebiegu można porządkować ciąg o jeden element krótszy. Sortowanie kończy się kiedy do posortowania zostanie tylko jeden element. Istnieją inne, ulepszone warianty sortowania bąbelkowego – jeśli w pewnym przebiegu algorytmu ostatnia zamiana elementów nastąpi na i-tej pozycji, w kolejnym przebiegu można sortować tylko elementy na pozycjach do poprzedzającego ten element, z czego wynika, iż ten algorytm dla uporządkowanych danych wejściowych wykona tylko jeden obieg – będzie miał dobrą złożoność dla optymistycznych danych. ",

  "sortowanie przez wybór": "Sortowanie przez wybór (rosnąco) polega na wyborze z danych wejściowych najmniejszego elementu i zamiana go z pierwszym elementem, potem wybór kolejnego najmniejszego z danych pomijając pierwszy element i zamiana go z drugim, i tak dalej, aż zostanie ostatni element, wtedy sortowanie się kończy. Szukanie najmniejszego elementu realizuje się przez porównanie kolejnych elementów najpierw z pierwszym, a potem z mniejszym od niego jeśli taki się znajdzie. ",

  "sortowanie szybkie": "Sortowanie szybkie, podobnie jak sortowanie przez scalanie wykorzystuje strategie „dziel i zwyciężaj” oraz tak samo polega na podziale danych wejściowych na dwie tablice, jednak mogą one być dowolnej długości. Elementy jednej z nich muszą być mniejsze od elementów drugiej. Aby to zrobić należy wybrać jeden element tablicy i wszystkie mniejsze od niego przenieść do pierwszej tablicy a większe do drugiej. Dla każdej z tych tablic należy powtarzać te operacje, aż zostaną tablice jedno-elementowe. Na koniec wystarczy połączyć wszystkie powstałe w ten sposób tablice w jedną. ",

  "sortowanie przez wstawianie": "Idea algorytmu sortowania przez wstawianie polega na wstawianiu kolejnych elementów tablicy wejściowej do pustej na początku tablicy wyjściowej w odpowiednim miejscu. Na wybór miejsca, do którego wstawimy element są różne podejścia. Najprostszym sposobem jest porównanie tego elementu z kolejnymi elementami tablicy wyjściowej i wstawienie go na pozycje przed pierwszym elementem większym od niego (dla sortowania rosnącego). Sortowanie kończy się kiedy nie pozostanie żaden element do wstawienia. ",

  "sortowanie przez scalanie": "Ten rodzaj algorytmu wykorzystuje strategie „dziel i zwyciężaj”, a więc dzieli sortowaną tablicę wejściową na dwie równe części  (lub różniące się jednym elementem dla tablicy o nieparzystej liczbie elementów), sortuje każdą z tych części sortowaniem przez scalanie (czyli tym właśnie opisywanym) oraz łączy obie części porównując ze sobą pierwsze elementy każdej z nich, a mniejszy wstawia do nowego ciągu, czynność powtarza aż wstawi do nowego ciągu wszystkie elementy.",

  "sortowanie przez zliczanie": "counting sort opis",

  "sortowanie przez kopcowanie": "Sortowanie przez kopcowanie można podzielić na dwie fazy. Pierwsza z nich polega na utworzeniu z danych wejściowych kopca. Kopiec jest drzewem binarnym, czyli strukturą danych w której każdy element ma co najwyżej dwa elementy potomne, które dodatkowo spełnia następujący warunek: każdy element będący rodzicem musi być większy lub równy od swoich potomków (dla sortowania malejącego odwrotnie – mniejszy lub równy). Kopiec można przedstawić w tablicy, w której drugi i trzeci element będą potomkami pierwszego, czwarty i piąty będą potomkami drugiego itd. Budowę kopca z danych wejściowych zaczyna się od pierwszego elementu który stanie się korzeniem, drugi i trzeci element będą jego dziećmi. Jeżeli któryś z dzieci pierwszego elementu będzie większy od pierwszego, należy zamienić ich miejsca, aby warunek bycia kopcem został zachowany. W kolejnym kroku dołącza się dwa kolejne elementy, będą one dziećmi elementu drugiego. Jeżeli jest on większy od swojego rodzica znowu należy zamienić ich położenie oraz sprawdzić po tej zamianie element który stał się rodzicem nie jest mniejszy, jeśli tak znowu zamienić je miejscami. Czynność powtarzamy aż nie zostanie elementów w tablicy wejściowej."
}
